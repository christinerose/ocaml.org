let render () =
Layout.render 
~title:"Why OCaml?"
~description:"OCaml is a mature, statically-typed, functional programming language. Learn more about its rich history and what makes it unique." @@
<div class="intro-section-simple">
  <div class="container-fluid">
    <div class="text-center w-full lg:w-2/3 m-auto">
      <h1 class="font-bold mb-6">Why OCaml?</h1>
      <div class="flex items-center justify-center space-x-8 mt-11 lg:space-x-24">
        <div>
          <a
            class="hover:text-primary-600 rounded-lg hover:bg-primary-100 h-28 w-28 inline-block transition-colors"
            href="#strength"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-10 w-10 mb-4 m-auto mt-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            <div class="font-semibold text-lg">Strengths</div>
          </a>
        </div>
        <div>
          <a
            class="hover:text-primary-600 h-28 w-28 rounded-lg hover:bg-primary-100 inline-block transition-colors"
            href="#history"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-10 w-10 mb-4 m-auto mt-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
            <div class="font-semibold text-lg">History</div>
          </a>
        </div>
        <div>
          <a
            class="hover:text-primary-600 h-28 w-28 rounded-lg hover:bg-primary-100 inline-block transition-colors"
            href="#features"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-10 w-10 mb-4 m-auto mt-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
              />
            </svg>
            <div class="font-semibold text-lg">Features</div>
          </a>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="bg-white">
  <div class="py-10 lg:py-28">
    <div class="container-fluid">
      <div class="prose lg:prose-lg mx-auto max-w-5xl">
        <h2 id="strength">Why OCaml?</h2>
        <div class="space-y-10">
          <p>
            Programming languages matter. They affect the reliability, security, and efficiency of the code you write,
            as well as how easy it is to read, refactor, and extend. The languages you know also change how you
            think, influencing the way you design software even when you’re not using them.
          </p>
           <p>
            It’s become a bit of a myth that OCaml is an academic language mostly used for research. 
            In reality, OCaml has several specialised tools that enable developers to create practical and powerful 
            code that scales.
          </p>
          <p>
            OCaml mixes power and pragmatism in a way that makes it ideal for building complex software systems. What
            makes OCaml special is that it occupies a sweet spot in the world of programming language design. It provides a
            combination of efficiency, expressiveness, and practicality that is matched by no other language. That is in
            large part due to OCaml's elegant combination of language features that have been developed over the
            last 40 years. These include:
          </p>
          <ul>
            <li>
              <strong>Garbage collection (GC)</strong> for automatic memory management, now a feature of almost every
              modern, high-level language.
            </li>
            <li>
              <strong>First-class functions</strong> that can be passed around like ordinary values, as seen in
              JavaScript, Common Lisp, and C#.
            </li>
            <li>
              <strong>Static type-checking</strong> to increase performance and reduce the number of runtime errors, as
              found in Java and C#.
            </li>
            <li>
              <strong>Parametric polymorphism</strong>, which enables the construction of abstractions that work across
              different data types, similar to generics in Java and C# and templates in C++.
            </li>
            <li>
              Good support for <strong>immutable programming</strong>, i.e., programming without making destructive
              updates to data structures. This is present in traditional functional languages like Scheme, and it's also
              found in distributed, big-data frameworks like Hadoop.
            </li>
            <li>
              <strong>Type inference</strong>, so you don’t need to annotate every single variable in your program with
              its type. Instead, types are inferred based on how a value is used. Available in a limited form in C# with
              implicitly-typed local variables and in C++11 with its auto keyword.
            </li>
            <li>
              <strong>Algebraic data types</strong> and <strong>pattern matching</strong> to define and manipulate
              complex data structures, available in Scala and F#.
            </li>
          </ul>
          
          <p>
            Having all these features together and able to interact in a single
            language creates amazing synergy, making it better than the sum of its parts. 
            Despite their importance, these ideas have made only limited inroads into mainstream languages.
            When they do arrive, like first-class functions in C# or parametric polymorphism in Java, it’s
            typically in a limited form. The only languages that completely embody these ideas are
            statically-typed, functional programming languages like OCaml, F#, Haskell, Scala, Rust, and Standard ML.
          </p>
          <p>
            Among this worthy set of languages, OCaml stands apart because it packs a big punch when it comes to power
            without sacrificing pragmatism. The compiler has a straightforward compilation strategy that produces
            performant code without requiring heavy optimization and the complexities of dynamic just-in-time
            (JIT) compilation. 
          </p>
          <p>
            This, along with OCaml’s strict evaluation model, makes runtime behaviour easy to predict.
            The garbage collector is incremental, (letting you avoid long GC-related pauses) and precise, meaning it
            will collect all unreferenced data (unlike many reference-counting collectors). As a bonus, the runtime is simple
            and highly portable. These features make OCaml a great choice for programmers who want to upgrade to a functional 
            programming language that lets them get practical work done.
          </p>
          <h2 id="features">Additional Features</h2>
          <ul>
            <li>
              <strong>Separate compilation of standalone applications:</strong>
              Portable bytecode compilers make it possible to create stand-alone applications using OCaml programs. For
              example, OCaml code can interact with C code via a foreign function interface, which has
              allowed it to be used commercially to prove the absence of runtime errors in safety-critical software for
              the Airbus A340 family.
            </li>
            <li>
              <strong>A sophisticated module system:</strong>
              You can think of OCaml as being divided into two parts: a core language, concerned with values and types,
              and a module language that's concerned with modules and module signatures. OCaml's mudule system is
              incredibly powerful. For instance, it allows you to parameterise one module over another. This makes it
              possible to concisely and safely build up layers of abstraction in large pieces of software.
            </li>
            <li>
              <strong>Object-oriented programming:</strong>
              OCaml allows for writing programs in an object-oriented style. In keeping with OCaml's emphasis on safety,
              the object-oriented layer obeys the "strong typing" paradigm, which makes it impossible to send a message
              to an object that cannot answer it. This prevents the introduction of errors and keeps the code crash-free. 
              This safety does not come at the cost of expressiveness, however. Thanks to
              features such as multiple inheritance and parametric classes, complex design patterns can
              be expressed in a natural manner.
            </li>
            <li>
              <strong>Debugging facilities:</strong>
              There are several different methods available for debugging OCaml programs. The interactive Read-Eval-Print Loop (REPL) offers an
              elementary, yet fast and simple method to test functions. For more complex cases, the interactive system
              provides an easy way of "tracing" computations. Finally, OCaml has an extremely powerful tool for
              following a program's execution called the Symbolic Relay Debugger. It enables the user to stop a program
              at any time to scrutinise the value of variables and the stack of calling functions. It even allows the user to go
              back and resume execution at particular points of interest.
            </li>
            <li>
              <strong>Efficient compiler, efficient compiled code:</strong>
              OCaml offers two batch compilers: a bytecode compiler and a native code compiler. Bytecode compilers
              quickly generate small, portable executables. The native code compiler is slower, but it produces more
              efficient machine code, whose performance meets the highest standards of modern compilers.
            </li>
            <li>
              <strong>Portability:</strong>
              OCaml runs on a wide variety of platforms: both officially supported platforms as well as
              platforms supported by the community. For example, 
              it is possible to compile OCaml to JavaScript with Js_of_ocaml, and OCaml-Java enables direct 
              compilation of OCaml to Java bytecode, enabling the creation of rich,
              client-side applications. There are now OCaml apps available on the Apple App store!
            </li>
          </ul>
          <p>
            <small>
              (This page is adapted from the
              <a href="https://dev.realworldocaml.org/prologue.html#why-ocaml">"Why OCaml" section</a>
              of <em>Real World OCaml</em>)
            </small>
          </p>
        </div>
      </div>
    </div>
  </div>
</div>
